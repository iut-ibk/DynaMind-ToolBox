__author__ = 'Jeddah'
__project__ = "WaterDemandMdeol"


import sampling_db as DB
import C_ApplianceType as Appliance
import C_UnitType as Unit
import C_ResidentialUnit as residential
import C_CommercialUnit as commercial


class WaterDemandModel():
    """

    """

    __residential_units = []          # the number of residential units represented by an array. Where the integer at each index represent the number of actors in the unit. i.e. [3,4] = 2 units of 3 and 4 res actors respectively
    __commercial_units = []           # the number of commercial units represented by an array. Where the integer at each index represent the number of actors in the unit. i.e. [10,15] = 2 units of 10 and 15 res actors respectively
    __unit_type = str

    __timeseries = {}     # is the dictionary initialised at the start of each day to store the volumes of water generated by each appliance at an hourly timestep. As well as the number of actors in the building
    __demand_output = {}

    def __init__(self,residential_units,commercial_units):

        self.__residential_units = residential_units
        self.__commercial_units = commercial_units
        self.__unit_type = str
        self.__demand_output = {}
        print residential_units
        print self.__residential_units
        self.__timeseries = WaterDemandModel.getInitialisedTimeseries(self)

        #initialise methods:
        self.initialiseTimeseries()
        self.run()


    def initialiseTimeseries(self):
        """
        This method initialises a timeseries array for each event and places it within the dictionary called 'timeseries'. The key of the dictionary is the unit_type (from C_Unit_TYpe) e.g. "COMMERCIAL" and appliance_type (from C_Appliances()) e.g. 'toilet'.
        For each appliance key an array of zeros is initialised. Where each zero represents one timestep of the timeseries. Volumes generated at different time steps can then be used to populate the initialised timeseries array.
        The size of the array is dependant on the input 'elements'. Arrays for each appliance are made for all of the unit_types.

        A key for the number of actors ("actors") is also initialised in this method

        :return: an initialised dictionary {RESIDENTIAL:{event_type1:[0,0,0,0,0....n(elements)],event_type2: [0,0,0,0,0,0,....n(elements)],actors: 0.0}
        """

        for u_type in Unit.unit_types:                 # for each of the unit types (e.g. residential, commercial etc.)

            self.__timeseries[u_type] = {}                        # make a nested dictionary (e.g. timeseries = {'commercial': {} :, 'residential' :{}, }
            self.__timeseries[u_type]["actors"]= 0.0              # create a key for the number of actors. Initialise it with a zero

            # appliances used depend on unit type, therefore grab the correct appliance list:

            if u_type == "RESIDENTIAL":
                appliances = Appliance.residential_appliance_types
            elif u_type == "COMMERCIAL":
                appliances = Appliance.commercial_appliance_types
            else:
                print "error: the unit type does not exist"

            # create an array of zero's for each appliance in the unit:

            for a_type in appliances:       # for all of the appliance types e.g. toilet, shower, etc.
                array = []                                  # make a empty array
                for i in range(24):               # for each step in the timeseries of 24hrs:
                    array.append(0.0)                            # add a zero to a
                self.__timeseries[u_type][a_type] = array               # append it to the relevant array in the dictionary specified by unit type and appliance type.

    def getInitialisedTimeseries(self):

        return self.__timeseries

    def createTimeSeries(self,events,unit_type,numberOfActors):
        """
        This method is used to create a timeseries of water use volumes for each end use (event_type) within each unit type.
        It does this by extracting the relevant information (volume, time) from the event objects generated by the relevant unit class
        For each event_type a different array of water use volumes (at each hour of the day) is generated.
        This information is stored in the form of a dictionary.

        The method also adds the number of actors within the unit - based on inputs to the method

        :param events: All the water use event objects from each appliance
        :param unit_type: i.e. Comm or Res. Required for the dictionary key to attach the relevant number of actors
        :param numberOfActors: number of actors (people) within the unit being modelled

        :return: A filled in dictionary containing the water use volumes at each hour of the day for each appliances and the number of actors within
                 the unit.
        """

        self.__timeseries[unit_type]["actors"] = numberOfActors         # get the number of actors

        for e in events:                            # for all of the water events generated by a household:
            u_type = e.getUnitType()                # get the unit type of the event (i.e is the event occurring in a residential unit or commercial unit)

            # For individual event types:
            volumes = self.__timeseries[u_type][e.getAppliance()]    # From the dictionary, get the initialised array for the specific event_type.
                                                                     # Each time it goes through the loop, it calls up the correct array (corresponding to the key),
                                                                     # and adds the volume to it that is generated at a specific time using the code below.
            start = e.getStartTime()                    # get the start time of the event
            volume = e.getVolume()                      # get the volume of the event
            volumes[int(start)] += volume               # Add the volume generated to the relevant timestep of the volumes array (who's index is the same as that of the start time)


    def run(self):
        """
        This method is used to call all relevant methods within the WaterDemandModel code. It creates water demand
        timeseries for a specified number of commercial and residential units.

        :return: dictionary of the water volumes (L) made at each time step for each appliance. And the number of actors in the unit.
        """

        "RESIDENTIAL EVENTS"

        res_name_counter = 1        # used to create a name for each unit e.g. R1, R2
        res_actor_counter = 0       # represents the index of the res_unit array --> so the relevant number of people can be returned
        print self.__residential_units
        for i in range(len(self.__residential_units)):        # for the number of res units specified:

            # create a res unit ID R1 --> Rn
            res_name = "R" + str(res_name_counter)
            self.__demand_output[res_name] = {}
            res_name_counter += 1

            # get the number of actors in the unit from the input vector:
            number_of_residential_actors = self.__residential_units[res_actor_counter]
            res_actor_counter += 1

            r = residential.ResidentialUnit(number_of_residential_actors)                   # instantiate the Residential Unit Class (with the number of actors)

            all_resident_unit_events = r.getAllUnitEvents()                                 # get all of the residential unit events

            self.createTimeSeries(all_resident_unit_events,"RESIDENTIAL",number_of_residential_actors)      # populate the empty dictionary with volumes for each appliance. Append the number of actors.

            self.__demand_output[res_name] = self.__timeseries["RESIDENTIAL"]                             # append the populated dictionary to the output dictionary. Only return Residential information. Otherwise an empty dictionary for Commercial is returned as well.

        "COMMERCIAL EVENTS"

        com_name_counter = 1        # used to create a name for each unit e.g. C1, C2
        com_actor_counter = 0       # represents the index of the res_unit array --> so the relevant number of people can be returned

        for j in range(len(self.__commercial_units)):   # for the number of commercial units specified:

            # create a res unit ID C1 --> Cn
            comm_name = "C" + str(com_name_counter)
            self.__demand_output[comm_name] = {}
            com_name_counter += 1

            # get the number of actors in the unit from the input vector:
            number_of_commercial_actors = self.__commercial_units[com_actor_counter]
            com_actor_counter += 1

            c = commercial.CommercialUnit(number_of_commercial_actors)      # instantiate the Commercial Unit Class (with the number of actors)

            all_commercial_unit_events = c.getAllUnitEvents()               # get all of the commercial unit events

            self.createTimeSeries(all_commercial_unit_events,"COMMERCIAL",number_of_commercial_actors)        # populate the empty dictionary with volumes for each appliance. Append the number of actors.

            self.__demand_output[comm_name] = self.__timeseries["COMMERCIAL"]            # append the populated dictionary to the output dictionary. Only return Commercial information. Otherwise an empty dictionary for Residential is returned as well.

    def getDemands(self):

        return self.__demand_output

if __name__ == "__main__":

    res_units = [2]
    com_units = [8]

    run = WaterDemandModel(res_units,com_units)

    a = run.getDemands()
    print  run.getDemands()




